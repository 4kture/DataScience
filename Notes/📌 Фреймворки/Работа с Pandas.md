
**Pandas** — **программная библиотека на языке Python для обработки и анализа данных**.

---

## **1. Чтение данных**

Pandas поддерживает загрузку данных из множества источников. Ниже приведены примеры чтения данных и пояснения к коду.

### Примеры:

```python
import pandas as pd

# Чтение CSV-файла
df = pd.read_csv('file.csv')  # Загружаем CSV. По умолчанию, разделитель — запятая.
df = pd.read_csv('file.csv', sep=";")  # Если разделитель — точка с запятой.

# Чтение TXT или TSV-файла (разделитель — табуляция)
df = pd.read_csv('file.txt', sep="\t")

# Чтение Excel-файла
df = pd.read_excel('file.xlsx', sheet_name='Sheet1')  # sheet_name указывает, какой лист Excel загружать.

# Чтение JSON-файла
df = pd.read_json('file.json')  # Загрузка данных из JSON.

# Чтение из базы данных SQL
import sqlite3
conn = sqlite3.connect('database.db')  # Подключаемся к базе SQLite.
df = pd.read_sql('SELECT * FROM table_name', conn)  # Выполняем SQL-запрос.
```

### Объяснения:

1. **`read_csv`** — самая популярная функция, так как данные часто приходят в формате CSV.
    - **`sep`** — разделитель столбцов. По умолчанию это запятая, но можно указать, например, `sep="\t"` для табуляции или `sep=";"` для точек с запятой.
2. **`read_excel`**:
    - **`sheet_name`** — имя листа в файле Excel. Если в файле один лист, можно его не указывать.
3. **`read_sql`**:
    - Используется для загрузки данных напрямую из базы данных.
    - **`conn`** — это объект подключения к базе.

---

## **2. Сохранение данных**

После работы с данными их нужно сохранить. Вот примеры сохранения в разных форматах:

### Примеры:

```python
# Сохранение в CSV
df.to_csv('output.csv', index=False)  # Сохраняем данные без индекса.

# Сохранение в Excel
df.to_excel('output.xlsx', index=False)  # Сохраняем в формате Excel.

# Сохранение в JSON
df.to_json('output.json', orient='records')  # Сохраняем в виде массива записей (records).
```

### Объяснения:

1. **`to_csv`**:
    - **`index`** — если `False`, не сохраняется индекс (номера строк).
2. **`to_excel`**:
    - Работает аналогично `to_csv`, только сохраняет в Excel.
3. **`to_json`**:
    - **`orient`** — определяет, как будет организован JSON. Например, `orient='records'` создаёт список объектов.

---

## **3. Основные операции с DataFrame**

### Примеры:

```python
# Просмотр данных
df.head()  # Первые 5 строк (по умолчанию).
df.tail()  # Последние 5 строк.
df.sample(5)  # 5 случайных строк.
df.info()  # Информация о структуре данных.
df.describe()  # Статистика для числовых столбцов.
```

### Объяснения:

1. **`head` и `tail`** — удобны для быстрого просмотра начала и конца таблицы.
2. **`info`** — показывает типы данных столбцов, количество строк и наличие пропусков.
3. **`describe`** — генерирует основные статистические параметры (среднее, минимальное, максимальное и др.).

---

## **4. Выбор данных**

### Примеры:

```python
# Выбор столбца
df['column_name']  # Один столбец (возвращает Series).
df[['col1', 'col2']]  # Несколько столбцов (возвращает DataFrame).

# Фильтрация строк
df[df['column_name'] > 100]  # Строки, где значение в column_name больше 100.
df[df['category'] == 'A']  # Строки, где категория равна 'A'.

# Выбор строк и столбцов через loc и iloc
df.loc[0, 'column_name']  # Значение из строки 0 и столбца column_name.
df.iloc[0, 0]  # Значение из строки 0 и столбца 0 (по индексу).
```

### Объяснения:

1. **`df['column_name']`** — возвращает данные одного столбца. Работает без `print`, вывод сразу виден.
2. **`loc`** — доступ к данным по имени строки и столбца.
3. **`iloc`** — доступ к данным по числовым индексам.

---

## **5. Работа с пропусками**

### Примеры:

```python
# Проверка на пропуски
df.isna().sum()  # Количество NaN в каждом столбце.

# Заполнение пропусков
df['column_name'] = df['column_name'].fillna('Неизвестно')  # Заменяем NaN на строку.
df['column_name'] = df['column_name'].fillna(df['column_name'].mean())  # Заменяем NaN на среднее.

# Удаление строк с NaN
df = df.dropna()  # Удаляет строки, где есть хотя бы один NaN.
```

### Объяснения:

1. **`isna`** — показывает, где есть пропуски.
2. **`fillna`** — заполняет пропуски указанным значением (средним, медианой или строкой).
3. **`dropna`** — удаляет строки или столбцы с пропусками.

---

## **6. Агрегации и группировки**

### Примеры:

```python
# Группировка и агрегация
grouped = df.groupby('category')['value'].mean()  # Среднее по категориям.
grouped = df.groupby('category').agg({'value': ['mean', 'sum']})  # Среднее и сумма.
```

### Объяснения:

1. **`groupby`** — группирует данные по указанному столбцу.
2. **`agg`** — позволяет применять сразу несколько функций агрегации.

---

## **7. Сортировка и дубликаты**

### Примеры:

```python
# Сортировка
df = df.sort_values(by='column_name', ascending=False)  # Сортировка по убыванию.

# Работа с дубликатами
df = df.drop_duplicates()  # Удаление повторяющихся строк.
```

### Объяснения:

1. **`sort_values`**:
    - **`by`** — имя столбца, по которому сортируем.
    - **`ascending`** — если `True`, сортировка по возрастанию.
2. **`drop_duplicates`** — удаляет строки, которые повторяются.

---

## **8. Работа с датами**

### Примеры:

```python
df['date'] = pd.to_datetime(df['date_column'])  # Преобразуем в формат даты.
df['year'] = df['date'].dt.year  # Извлекаем год.
df['month'] = df['date'].dt.month  # Извлекаем месяц.
```

### Объяснения:

1. **`to_datetime`** — конвертирует строковый столбец в даты.
2. **`dt.year` и другие** — позволяют работать с компонентами даты.

---
